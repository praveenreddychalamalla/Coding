 /**
 * @author Praveen Reddy Chalamalla
 * @create date 2021-12-26
 * @desc Word Ladder I
 */

//Time Complexity - O(n^2 * m), Space Complexity - O(n * m). N = length of wordList and M = |wordListi|

#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    int wordLadderLength(string startWord, string targetWord, vector<string>& wordList) {
        unordered_map<string,int>m;
        int n=wordList.size();
        for(int i=0;i<n;i++)m[wordList[i]]=1;
        queue<string>q;
        int level=0;
        q.push(startWord);
        while(!q.empty()){
            level++;
            int k=q.size();
            while(k--){
                
                string s=q.front();
                if(s==targetWord)return level;
                if(m.find(s)!=m.end()) m.erase(m.find(s)); //Erase the popped word from map. Does the visited array job ):-
                
                q.pop();
                int l=s.length();
                for(int i=0;i<l;i++){ //Try all the possible words which can be generated by changing only one letter in the word and which is in wordList 
                    string temp=s;
                    for(int j=0;j<26;j++){
                        temp[i]='a'+j;
                        if(m.find(temp)!=m.end()){
                            q.push(temp);
                        }
                    }
                }
            }
        }
        return 0;
    }
};